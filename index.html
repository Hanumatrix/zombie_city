<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Zombie City - Realistic Build</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Segoe UI", sans-serif;
        background: #000;
        width: 100vw;
        height: 100vh;
      }
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        text-shadow: 2px 2px #000;
        pointer-events: none;
        display: none;
        z-index: 10;
        font-size: clamp(12px, 2vw, 18px);
      }
      #health-container {
        width: clamp(150px, 30vw, 250px);
        height: 15px;
        background: #444;
        border: 2px solid #000;
        margin-top: 5px;
        border-radius: 10px;
        overflow: hidden;
      }
      #health-bar {
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, #ff4b2b, #ff416c);
        transition: width 0.3s;
      }
      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 6px;
        height: 6px;
        background: #00ff00;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        border: 2px solid rgba(0, 0, 0, 0.5);
        z-index: 5;
      }
      #menu,
      #game-over {
        position: fixed;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, #2c3e50, #000);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        z-index: 100;
        text-align: center;
      }
      #game-over {
        display: none;
      }
      button {
        padding: 15px 40px;
        font-size: clamp(14px, 2vw, 18px);
        background: #e74c3c;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 5px;
        font-weight: bold;
        margin-top: 20px;
        transition: background 0.3s;
      }
      button:hover {
        background: #c0392b;
      }
      input {
        font-size: clamp(12px, 2vw, 16px);
      }
      .boss-txt {
        color: #ff0000;
        font-weight: bold;
        animation: blink 1s infinite;
        display: none;
        font-size: clamp(14px, 2vw, 20px);
      }
      #ammo-counter {
        margin-top: 10px;
        color: #ffaa00;
      }
      #multiplayer-info {
        position: absolute;
        bottom: 20px;
        right: 20px;
        color: #00ff00;
        font-size: clamp(10px, 1.5vw, 14px);
        display: none;
        pointer-events: none;
      }
      @keyframes blink {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
        100% {
          opacity: 1;
        }
      }
      @keyframes pulse {
        0% {
          transform: translate(-50%, -50%) scale(0.3);
          opacity: 0;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.15);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
      }
      #wave {
        font-size: clamp(12px, 2vw, 16px);
      }
      #pName {
        margin-bottom: 5px;
      }
      #pause-menu {
        position: fixed;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        z-index: 99;
      }
      #pause-menu.active {
        display: flex;
      }
      #pause-menu h1 {
        font-size: clamp(2rem, 8vw, 3rem);
        margin: 0;
        margin-bottom: 30px;
      }
      #pause-menu button {
        padding: 15px 40px;
        font-size: clamp(14px, 2vw, 18px);
        margin-bottom: 15px;
        cursor: pointer;
        border: none;
        color: white;
        border-radius: 5px;
        font-weight: bold;
        transition: background 0.3s;
      }
      #pause-menu button:first-of-type {
        background: #27ae60;
      }
      #pause-menu button:first-of-type:hover {
        background: #229954;
      }
      #pause-menu button:last-of-type {
        background: #e74c3c;
      }
      #pause-menu button:last-of-type:hover {
        background: #c0392b;
      }
      @media (max-width: 768px) {
        #ui {
          top: 10px;
          left: 10px;
          background: rgba(0, 0, 0, 0.4);
          padding: 10px;
          border-radius: 5px;
        }
        #crosshair {
          width: 8px;
          height: 8px;
        }
        #multiplayer-info {
          bottom: 10px;
          right: 10px;
          background: rgba(0, 0, 0, 0.4);
          padding: 8px;
          border-radius: 3px;
        }
        #menu h1 {
          margin-bottom: 10px;
        }
        button {
          width: 90vw;
          max-width: 250px;
        }
        input {
          width: 90vw;
        }
      }
    </style>
  </head>
  <body>
    <div id="menu">
      <div
        style="
          display: flex;
          width: 100%;
          max-width: 1200px;
          gap: 40px;
          align-items: flex-start;
          justify-content: center;
          flex-wrap: wrap;
        "
      >
        <div style="flex: 1; min-width: 250px">
          <h1 style="font-size: clamp(2rem, 8vw, 3.5rem); margin: 0">
            ZOMBIE CITY
          </h1>
          <p style="letter-spacing: 2px; font-size: clamp(14px, 2vw, 18px)">
            REALISTIC SURVIVAL SIMULATOR
          </p>
          <input
            type="text"
            id="username"
            placeholder="NAME YOUR SURVIVOR"
            autocomplete="username"
            style="
              padding: 12px;
              width: 80vw;
              max-width: 250px;
              border-radius: 5px;
              border: none;
            "
          />
          <button onclick="startGame()">ENTER ARENA</button>
          <div style="margin-top: 30px; font-size: 12px; color: #aaa">
            <p>WASD: Move | Mouse: Look | Click: Shoot</p>
            <p>Survive the zombie apocalypse as long as you can</p>
          </div>
        </div>

        <div
          id="leaderboard-container"
          style="
            flex: 1;
            min-width: 320px;
            background: linear-gradient(
              135deg,
              rgba(20, 20, 30, 0.95),
              rgba(40, 0, 0, 0.95)
            );
            padding: 25px;
            border-radius: 15px;
            border: 3px solid #e74c3c;
            max-height: 550px;
            overflow-y: auto;
            box-shadow:
              0 0 30px rgba(231, 76, 60, 0.4),
              inset 0 0 20px rgba(231, 76, 60, 0.1);
          "
        >
          <h2
            style="
              background: linear-gradient(90deg, #e74c3c, #ffaa00);
              -webkit-background-clip: text;
              -webkit-text-fill-color: transparent;
              background-clip: text;
              margin: 0 0 20px 0;
              text-align: center;
              font-size: clamp(18px, 2.5vw, 24px);
              font-weight: bold;
              text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
              letter-spacing: 2px;
            "
          >
            ‚ò† HALL OF FAME ‚ò†
          </h2>
          <div id="leaderboard-list" style="font-size: 13px">
            <p style="text-align: center; color: #aaa">
              Loading leaderboard...
            </p>
          </div>
        </div>
      </div>
    </div>

    <div
      id="game-over"
      style="
        background: linear-gradient(
          135deg,
          rgba(192, 57, 43, 0.95),
          rgba(41, 14, 14, 0.95)
        );
        animation: fadeIn 0.5s ease-in;
      "
    >
      <div style="text-align: center">
        <h1
          style="
            font-size: clamp(2.5rem, 10vw, 5rem);
            color: #ff6b6b;
            margin: 0;
            text-shadow:
              0 0 20px rgba(255, 107, 107, 0.8),
              0 0 40px rgba(192, 57, 43, 0.6);
            letter-spacing: 3px;
          "
        >
          ‚ò† YOU DIED ‚ò†
        </h1>
        <p
          style="
            color: #ffaa00;
            font-size: clamp(12px, 2vw, 16px);
            margin: 15px 0;
            opacity: 0.9;
          "
        >
          Your body has fallen to the horde...
        </p>

        <div
          id="final-stats"
          style="
            font-size: clamp(14px, 2.5vw, 20px);
            margin: 30px 0;
            background: rgba(0, 0, 0, 0.5);
            padding: 25px 40px;
            border-radius: 10px;
            border: 2px solid #e74c3c;
            display: inline-block;
            min-width: 280px;
          "
        >
          <div style="color: #0f0; margin: 12px 0; font-weight: bold">
            üéØ Kills:
            <span id="stat-kills" style="color: #ffaa00; font-size: 1.2em"
              >0</span
            >
          </div>
          <div style="color: #0f0; margin: 12px 0; font-weight: bold">
            ‚è±Ô∏è Time:
            <span id="stat-time" style="color: #ffaa00; font-size: 1.2em"
              >0</span
            >s
          </div>
          <div style="color: #0f0; margin: 12px 0; font-weight: bold">
            üåä Wave:
            <span id="stat-wave" style="color: #ffaa00; font-size: 1.2em"
              >1</span
            >
          </div>
        </div>
      </div>
    </div>

    <style>
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.95);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }
    </style>

    <div id="pause-menu">
      <h1>GAME PAUSED</h1>
      <button onclick="resumeGame()">RESUME</button>
      <button onclick="returnToMenu()">RETURN TO MENU</button>
    </div>

    <div id="ui">
      <div
        id="pName"
        style="font-size: clamp(1.2rem, 3vw, 1.8rem); font-weight: bold"
      ></div>
      <div style="margin: 5px 0; font-size: clamp(12px, 2vw, 16px)">
        Kills: <span id="kills" style="color: #e74c3c">0</span> | Time:
        <span id="timer">0</span>s | Wave:
        <span id="wave" style="color: #ffaa00">1</span>
      </div>
      <div id="health-container"><div id="health-bar"></div></div>
      <div id="ammo-counter">Ammo: <span id="ammo">‚àû</span></div>
      <div id="boss-warning" class="boss-txt">‚ö† GIANT ZOMBIE APPROACHING ‚ö†</div>
    </div>
    <div id="crosshair"></div>
    <div id="multiplayer-info">Players: <span id="player-count">1</span></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
          "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
        }
      }
    </script>

    <script>
      // Make startGame globally accessible
      let startGameFunc = null;
      window.startGame = function () {
        if (startGameFunc) startGameFunc();
      };
    </script>

    <script type="module">
      import * as THREE from "three";
      import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
      import * as CANNON from "cannon-es";

      // Convex Configuration - UPDATE WITH YOUR DEPLOYMENT URL
      const CONVEX_URL = "https://tidy-curlew-553.convex.cloud";

      // Function to fetch and display leaderboard
      async function loadLeaderboard() {
        try {
          console.log("Loading leaderboard...");
          const response = await fetch(`${CONVEX_URL}/api/query`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              path: "gameStats:getTopScores",
              args: {},
            }),
          });

          if (!response.ok) {
            console.error("Failed to fetch leaderboard");
            return;
          }

          const data = await response.json();
          console.log("Leaderboard data:", data);

          // Extract the value array from the response
          const scores = data.value || data;

          const leaderboardList = document.getElementById("leaderboard-list");
          if (!scores || scores.length === 0) {
            leaderboardList.innerHTML =
              '<p style="text-align: center; color: #aaa;">No scores yet. Be the first!</p>';
            return;
          }

          let html =
            '<div style="display: flex; flex-direction: column; gap: 0;">';

          // Header row
          html +=
            '<div style="display: grid; grid-template-columns: 40px 100px 70px 80px 70px; gap: 12px; align-items: center; padding: 12px 10px; background: linear-gradient(90deg, rgba(231, 76, 60, 0.3), rgba(255, 170, 0, 0.2)); border-bottom: 2px solid #e74c3c; border-radius: 8px 8px 0 0; margin-bottom: 5px;">';
          html +=
            '<div style="color: #ffaa00; font-weight: bold; text-align: center;">RANK</div>';
          html +=
            '<div style="color: #ffaa00; font-weight: bold;">PLAYER</div>';
          html +=
            '<div style="color: #ffaa00; font-weight: bold; text-align: center;">KILLS</div>';
          html +=
            '<div style="color: #ffaa00; font-weight: bold; text-align: center;">TIME</div>';
          html +=
            '<div style="color: #ffaa00; font-weight: bold; text-align: center;">WAVES</div>';
          html += "</div>";

          scores.forEach((score, index) => {
            const rank = index + 1;
            const medal =
              rank === 1
                ? "ü•á"
                : rank === 2
                  ? "ü•à"
                  : rank === 3
                    ? "ü•â"
                    : `${rank}`;
            const bgColor =
              rank === 1
                ? "rgba(255, 170, 0, 0.2)"
                : rank === 2
                  ? "rgba(192, 192, 192, 0.15)"
                  : rank === 3
                    ? "rgba(205, 127, 50, 0.15)"
                    : "rgba(15, 255, 0, 0.05)";
            const textColor =
              rank === 1
                ? "#ffaa00"
                : rank === 2
                  ? "#e0e0e0"
                  : rank === 3
                    ? "#cd7f32"
                    : "#0f0";

            html += `<div style="display: grid; grid-template-columns: 40px 100px 70px 80px 70px; gap: 12px; align-items: center; padding: 12px 10px; background: ${bgColor}; border-left: 3px solid ${textColor}; border-radius: 5px; margin-bottom: 4px; transition: all 0.3s; cursor: pointer; hover-effect:"`;
            html += `onmouseover="this.style.background='${bgColor.replace("0.1", "0.35")}';" onmouseout="this.style.background='${bgColor}';">`;

            html += `<div style="color: ${textColor}; font-weight: bold; text-align: center; font-size: 16px;">${medal}</div>`;
            html += `<div style="color: ${textColor}; font-weight: bold; overflow: hidden; text-overflow: ellipsis;">${score.username.substring(0, 12)}</div>`;
            html += `<div style="color: #e74c3c; font-weight: bold; text-align: center; font-size: 14px;">${score.kills}</div>`;
            html += `<div style="color: #0f0; text-align: center;">${score.time}s</div>`;
            html += `<div style="color: #0f0; text-align: center;">${score.waves}</div>`;
            html += "</div>";
          });

          html += "</div>";
          leaderboardList.innerHTML = html;
        } catch (error) {
          console.error("Error loading leaderboard:", error);
          document.getElementById("leaderboard-list").innerHTML =
            '<p style="color: #e74c3c;">Failed to load leaderboard</p>';
        }
      }

      // Load leaderboard when page loads
      loadLeaderboard();

      // Refresh leaderboard every 10 seconds
      setInterval(loadLeaderboard, 10000);

      function showScoreSavedPopup(kills, time) {
        const popup = document.createElement("div");
        popup.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: linear-gradient(135deg, rgba(52, 152, 219, 0.98), rgba(41, 82, 170, 0.98));
          padding: 40px;
          border-radius: 15px;
          box-shadow: 0 0 30px rgba(52, 152, 219, 0.6);
          text-align: center;
          z-index: 9999;
          border: 3px solid #2ecc71;
          animation: popupSlide 0.5s ease-out;
        `;
        popup.innerHTML = `
          <h2 style="color: #2ecc71; margin: 0 0 15px 0; font-size: 24px;">‚úÖ SCORE SAVED!</h2>
          <p style="color: #fff; margin: 10px 0; font-size: 16px;">üéØ Kills: <span style="color: #ffaa00; font-weight: bold;">${kills}</span></p>
          <p style="color: #fff; margin: 10px 0; font-size: 16px;">‚è±Ô∏è Time: <span style="color: #ffaa00; font-weight: bold;">${time}s</span></p>
          <button onclick="location.reload()" style="
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            padding: 12px 40px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.5);
            transition: all 0.3s ease;
          " onmouseover="this.style.boxShadow='0 0 25px rgba(46, 204, 113, 0.8)'" onmouseout="this.style.boxShadow='0 0 15px rgba(46, 204, 113, 0.5)'">üîÑ TRY AGAIN</button>
        `;
        document.body.appendChild(popup);
      }

      // Function to get user IP address
      async function getClientIP() {
        try {
          const response = await fetch("https://api.ipify.org?format=json");
          const data = await response.json();
          return data.ip;
        } catch (e) {
          console.log("Could not fetch IP, using default");
          return "unknown";
        }
      }

      // Function to save game stats to Convex
      async function saveGameStats(username, kills, time, waves) {
        try {
          console.log("Starting to save game stats...");
          console.log(
            "Username:",
            username,
            "Kills:",
            kills,
            "Time:",
            time,
            "Waves:",
            waves
          );

          const ipAddress = await getClientIP();
          console.log("IP Address:", ipAddress);

          console.log("Calling Convex mutation...");

          // Make direct HTTP call to Convex
          const response = await fetch(`${CONVEX_URL}/api/mutation`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              path: "gameStats:saveGameStats",
              args: {
                username: username,
                ipAddress: ipAddress,
                kills: kills,
                time: time,
                waves: waves,
              },
            }),
          });

          console.log("Response status:", response.status);

          if (!response.ok) {
            const errorText = await response.text();
            console.error("Response error:", errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }

          const result = await response.json();
          console.log("‚úÖ Game stats saved successfully:", result);
          setTimeout(() => {
            showScoreSavedPopup(kills, time);
          }, 2000);
        } catch (error) {
          console.error("‚ùå Error saving game stats:", error);
          console.error("Error message:", error.message);
          alert("Failed to save score: " + error.message);
        }
      }

      let scene, camera, renderer, controls, clock, muzzleFlash;
      let player = { health: 100, kills: 0, startTime: 0, isDead: false };
      let npcs = [],
        cars = [],
        trees = [],
        bloodSplatters = [],
        bombs = [],
        buildings = [],
        bats = [];
      let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false;
      let velocity = new THREE.Vector3(),
        direction = new THREE.Vector3();
      let isApocalypse = false;
      let lastGiantSpawnTime = 0;
      let lastBatSpawnTime = 0;
      let giantZombieCount = 0;
      let bombZombieCount = 0;
      let firstKillPlayed = false;

      // Pause System
      let isPaused = false;
      let pausedTime = 0;

      // Physics world
      let physicsWorld = null;
      let physicsBodies = {};

      const ARENA_SIZE = 50;
      const PLAYER_HEIGHT = 1.3;
      const COLLISION_RADIUS = 1.0;

      // Mobile Detection & Performance
      const isMobile =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        );
      let qualityLevel = isMobile ? 0.5 : 1;

      function detectPerformance() {
        // Reduce quality on mobile devices
        if (isMobile) {
          qualityLevel = 0.5;
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
        } else {
          qualityLevel = 1;
          renderer.setPixelRatio(window.devicePixelRatio);
        }
        console.log(`Performance level: ${qualityLevel}, Mobile: ${isMobile}`);
      }

      function applyLOD(npc, distance) {
        // Level of Detail: simplify distant NPCs
        const LOD_THRESHOLD = 50;
        if (distance > LOD_THRESHOLD && qualityLevel < 1) {
          // Use lower detail geometry for distant NPCs on mobile
          npc.mesh.children.forEach((child) => {
            if (child.isMesh && child.geometry) {
              // Already using simple geometries, but could further optimize here
            }
          });
        }
      }

      function optimizeForMobile() {
        if (!isMobile) return;

        // Reduce particle counts on mobile
        const originalCreateBloodSplatter = createBloodSplatter;
        createBloodSplatter = function (position) {
          const splatterGroup = new THREE.Group();
          const particleCount = 15; // Reduced from 30

          for (let i = 0; i < particleCount; i++) {
            const size = 0.08 + Math.random() * 0.15;
            const geometry = new THREE.SphereGeometry(size, 4, 4); // Reduced segments
            const bloodColor = new THREE.Color().setHSL(
              0 + Math.random() * 0.05,
              0.7 + Math.random() * 0.3,
              0.25 + Math.random() * 0.15
            );
            const material = new THREE.MeshBasicMaterial({
              color: bloodColor,
              transparent: true,
              opacity: 0.85,
            });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.copy(position);
            const angle = Math.random() * Math.PI * 2;
            const elevation = Math.random() * Math.PI * 0.3;
            const speed = 1.5 + Math.random() * 2;
            particle.velocity = new THREE.Vector3(
              Math.sin(elevation) * Math.cos(angle) * speed,
              (Math.random() + 1) * speed * 0.5,
              Math.sin(elevation) * Math.sin(angle) * speed
            );
            splatterGroup.add(particle);
          }
          scene.add(splatterGroup);
          bloodSplatters.push({
            mesh: splatterGroup,
            time: 0,
            lifetime: 2.0,
          });
        };

        // Reduce NPC count on mobile
        const spawnNPCLimit = isMobile ? 12 : 25;
        console.log(`Mobile optimization: Max NPCs = ${spawnNPCLimit}`);
      }
      let socket = null;
      let isMultiplayer = false;
      let otherPlayers = {};
      const MAX_PLAYERS = 4;

      function initMultiplayer(serverURL = null) {
        // Initialize WebSocket connection for multiplayer
        if (!serverURL) return; // Skip if no server URL provided

        try {
          socket = new WebSocket(serverURL);

          socket.onopen = () => {
            console.log("Connected to multiplayer server");
            isMultiplayer = true;
            document.getElementById("multiplayer-info").style.display = "block";

            // Send player join message
            socket.send(
              JSON.stringify({
                type: "join",
                playerName: player.name,
                position: camera.position,
              })
            );
          };

          socket.onmessage = (event) => {
            const message = JSON.parse(event.data);

            switch (message.type) {
              case "playerJoined":
                console.log(`${message.playerName} joined`);
                break;
              case "playerUpdate":
                updateRemotePlayer(message);
                break;
              case "playerLeft":
                removeRemotePlayer(message.playerId);
                break;
              case "playerCount":
                updatePlayerCount(message.count);
                break;
            }
          };

          socket.onerror = (error) => {
            console.log("Multiplayer connection error:", error);
            isMultiplayer = false;
          };

          socket.onclose = () => {
            console.log("Disconnected from multiplayer server");
            isMultiplayer = false;
            document.getElementById("multiplayer-info").style.display = "none";
            Object.keys(otherPlayers).forEach((id) => {
              removeRemotePlayer(id);
            });
          };
        } catch (e) {
          console.log("Could not connect to multiplayer server:", e);
        }
      }

      function sendPlayerUpdate() {
        if (!socket || socket.readyState !== WebSocket.OPEN) return;

        socket.send(
          JSON.stringify({
            type: "playerUpdate",
            position: camera.position,
            rotation: camera.rotation,
            health: player.health,
            kills: player.kills,
          })
        );
      }

      function updateRemotePlayer(message) {
        const playerId = message.playerId;

        if (!otherPlayers[playerId]) {
          // Create new remote player
          const geometry = new THREE.BoxGeometry(0.6, 1.8, 0.4);
          const material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
          const mesh = new THREE.Mesh(geometry, material);
          scene.add(mesh);

          otherPlayers[playerId] = {
            mesh: mesh,
            name: message.playerName || "Player",
            lastUpdate: Date.now(),
          };
        }

        const player = otherPlayers[playerId];
        player.mesh.position.copy(
          new THREE.Vector3(
            message.position.x,
            message.position.y,
            message.position.z
          )
        );
        player.lastUpdate = Date.now();
      }

      function removeRemotePlayer(playerId) {
        if (otherPlayers[playerId]) {
          scene.remove(otherPlayers[playerId].mesh);
          delete otherPlayers[playerId];
        }
      }

      function updatePlayerCount(count) {
        document.getElementById("player-count").innerText = count;
      }
      let audioContext = null;
      let backgroundAudio = null;
      let soundEffects = {};
      let masterVolume = 0.5;

      function initPhysicsWorld() {
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.defaultContactMaterial.friction = 0.3;
        world.defaultContactMaterial.restitution = 0.3;
        return world;
      }

      function createSkinMaterial(baseColor = 0xffdbac) {
        // Custom shader for skin with realistic subsurface scattering effect
        const material = new THREE.ShaderMaterial({
          uniforms: {
            baseColor: { value: new THREE.Color(baseColor) },
            time: { value: 0 },
            lightPos: { value: new THREE.Vector3(50, 100, 50) },
          },
          vertexShader: `
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vWave;

            void main() {
              vNormal = normalize(normalMatrix * normal);
              vPosition = vec3(modelViewMatrix * vec4(position, 1.0));

              // Subtle wave deformation for realism
              vec3 pos = position;
              pos.y += sin(position.x * 2.0 + time * 2.0) * 0.02;
              pos.z += sin(position.y * 2.0 + time * 2.5) * 0.02;
              vWave = sin(position.x * 2.0 + time * 2.0) * 0.5 + 0.5;

              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 baseColor;
            uniform vec3 lightPos;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vWave;

            void main() {
              vec3 lightDir = normalize(lightPos - vPosition);
              float diffuse = max(dot(vNormal, lightDir), 0.0);

              // Subsurface scattering effect
              float backlight = max(dot(vNormal, -lightDir), 0.0) * 0.3;

              vec3 color = baseColor * (diffuse + 0.3) + vec3(backlight);
              gl_FragColor = vec4(color, 1.0);
            }
          `,
        });
        return material;
      }

      function createZombieMaterial(baseColor = 0x4caf50) {
        // Custom shader for zombie with sickly appearance
        const material = new THREE.ShaderMaterial({
          uniforms: {
            baseColor: { value: new THREE.Color(baseColor) },
            time: { value: 0 },
          },
          vertexShader: `
            varying vec3 vNormal;
            varying float vAlt;

            void main() {
              vNormal = normalize(normalMatrix * normal);
              vAlt = position.y;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 baseColor;
            uniform float time;
            varying vec3 vNormal;
            varying float vAlt;

            void main() {
              // Pulsating sickly glow
              float pulse = sin(time * 3.0) * 0.2 + 0.5;
              vec3 color = baseColor * (0.7 + pulse * 0.3);
              gl_FragColor = vec4(color, 1.0);
            }
          `,
        });
        return material;
      }

      function createClothMaterial(baseColor = 0x1565c0) {
        // Custom shader for cloth with better lighting
        const material = new THREE.ShaderMaterial({
          uniforms: {
            baseColor: { value: new THREE.Color(baseColor) },
            roughness: { value: 0.8 },
          },
          vertexShader: `
            varying vec3 vNormal;

            void main() {
              vNormal = normalize(normalMatrix * normal);
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 baseColor;
            uniform float roughness;
            varying vec3 vNormal;

            void main() {
              float light = dot(vNormal, normalize(vec3(1.0, 1.0, 1.0))) * 0.7 + 0.3;
              vec3 color = baseColor * light;
              gl_FragColor = vec4(color, 1.0);
            }
          `,
        });
        return material;
      }

      function initAudioContext() {
        if (!audioContext) {
          try {
            audioContext = new (
              window.AudioContext || window.webkitAudioContext
            )();
            if (audioContext.state === "suspended") {
              document.addEventListener("click", () => audioContext.resume(), {
                once: true,
              });
            }
          } catch (e) {
            console.log("Audio context not available");
          }
        }
        return audioContext;
      }

      function loadAudioFile(url) {
        return fetch(url)
          .then((response) => response.arrayBuffer())
          .then((arrayBuffer) => {
            const ctx = initAudioContext();
            if (!ctx) return null;
            return ctx.decodeAudioData(arrayBuffer);
          })
          .catch((e) => console.log("Audio load failed:", e));
      }

      function playAudioBuffer(audioBuffer, volume = 1) {
        const ctx = initAudioContext();
        if (!ctx || !audioBuffer) return;

        const source = ctx.createBufferSource();
        const gainNode = ctx.createGain();

        source.buffer = audioBuffer;
        gainNode.gain.value = volume * masterVolume;

        source.connect(gainNode);
        gainNode.connect(ctx.destination);
        source.start(0);

        return source;
      }

      function playLoopingAudio(audioBuffer, volume = 1) {
        const ctx = initAudioContext();
        if (!ctx || !audioBuffer) return;

        const source = ctx.createBufferSource();
        const gainNode = ctx.createGain();

        source.buffer = audioBuffer;
        source.loop = true; // Enable looping
        gainNode.gain.value = volume * masterVolume;

        source.connect(gainNode);
        gainNode.connect(ctx.destination);
        source.start(0);

        return source;
      }

      function playSimpleTone(
        frequency,
        duration,
        volume = 0.3,
        type = "sine"
      ) {
        const ctx = initAudioContext();
        if (!ctx) return;

        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(frequency, now);
        osc.frequency.exponentialRampToValueAtTime(
          frequency * 0.3,
          now + duration
        );

        gain.gain.setValueAtTime(volume * masterVolume, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + duration);

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start(now);
        osc.stop(now + duration);
      }

      function createEnvironmentalParticles() {
        // Creates dust/fog particles for atmosphere
        const dustGroup = new THREE.Group();
        const dustCount = 80;

        for (let i = 0; i < dustCount; i++) {
          const size = 0.1 + Math.random() * 0.3;
          const geometry = new THREE.SphereGeometry(size, 4, 4);
          const material = new THREE.MeshBasicMaterial({
            color: new THREE.Color(0x999999),
            transparent: true,
            opacity: 0.1 + Math.random() * 0.15,
          });
          const particle = new THREE.Mesh(geometry, material);
          particle.position.set(
            Math.random() * ARENA_SIZE * 2 - ARENA_SIZE,
            Math.random() * 20,
            Math.random() * ARENA_SIZE * 2 - ARENA_SIZE
          );
          dustGroup.add(particle);
        }

        scene.add(dustGroup);
        bloodSplatters.push({
          mesh: dustGroup,
          time: 0,
          lifetime: Infinity, // Stays forever, just moves slowly
          isEnvironmental: true,
        });
      }

      function createDebrisExplosion(position) {
        const debrisGroup = new THREE.Group();
        const debrisCount = 20;

        for (let i = 0; i < debrisCount; i++) {
          const size = 0.15 + Math.random() * 0.4;
          const geometry = new THREE.BoxGeometry(size, size * 0.7, size * 0.3);
          const material = new THREE.MeshStandardMaterial({
            color: new THREE.Color(0x666666).lerp(
              new THREE.Color(0x444444),
              Math.random()
            ),
            roughness: 0.8,
            metalness: 0.3,
          });
          const particle = new THREE.Mesh(geometry, material);
          particle.position.copy(position);

          const angle = Math.random() * Math.PI * 2;
          const elevation = Math.random() * Math.PI * 0.5;
          const speed = 1.5 + Math.random() * 2;

          particle.velocity = new THREE.Vector3(
            Math.sin(elevation) * Math.cos(angle) * speed,
            1.2 + Math.random() * 1.5,
            Math.sin(elevation) * Math.sin(angle) * speed
          );
          particle.angularVelocity = new THREE.Vector3(
            (Math.random() - 0.5) * 5,
            (Math.random() - 0.5) * 5,
            (Math.random() - 0.5) * 5
          );
          debrisGroup.add(particle);
        }

        scene.add(debrisGroup);
        bloodSplatters.push({
          mesh: debrisGroup,
          time: 0,
          lifetime: 2.5,
          isDebris: true,
        });
      }

      function checkBuildingCollision(position) {
        // Temporarily disabled collision for debugging movement
        return false;
        /*
        for (let building of buildings) {
          const distance = position.distanceTo(building.position);
          if (distance < building.size + COLLISION_RADIUS) {
            return true;
          }
        }
        return false;
        */
      }

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.015);

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowShadowMap;
        document.body.appendChild(renderer.domElement);

        // Detect performance and optimize for mobile
        detectPerformance();
        optimizeForMobile();

        // Initialize physics world
        physicsWorld = initPhysicsWorld();

        controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        // Set player camera height
        camera.position.y = PLAYER_HEIGHT;

        // Lighting - Enhanced with multiple sources
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // Main directional light (sun) with better shadows
        const sun = new THREE.DirectionalLight(0xffffff, 1.3);
        sun.position.set(50, 120, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = isMobile ? 1024 : 4096;
        sun.shadow.mapSize.height = isMobile ? 1024 : 4096;
        sun.shadow.camera.far = 500;
        sun.shadow.camera.left = -200;
        sun.shadow.camera.right = 200;
        sun.shadow.camera.top = 200;
        sun.shadow.camera.bottom = -200;
        sun.shadow.bias = -0.0001;
        scene.add(sun);

        // Add atmospheric light from horizon
        const horizonLight = new THREE.DirectionalLight(0xffaa88, 0.4);
        horizonLight.position.set(-100, 20, 100);
        scene.add(horizonLight);

        // Add point lights (skip on mobile for performance)
        if (!isMobile) {
          const pointLight1 = new THREE.PointLight(0xffdd99, 0.3, 100);
          pointLight1.position.set(-40, 30, -40);
          scene.add(pointLight1);

          const pointLight2 = new THREE.PointLight(0x99ddff, 0.2, 80);
          pointLight2.position.set(40, 25, 40);
          scene.add(pointLight2);
        }

        // Load background audio on init and play immediately
        loadAudioFile("public/videoplayback.mp3")
          .then((buffer) => {
            soundEffects.background = buffer;
            console.log("Background audio loaded successfully");
          })
          .catch((e) => console.log("Failed to load background audio:", e));

        // Load gunshot audio for shooting
        loadAudioFile("public/gunshot.m4a")
          .then((buffer) => {
            soundEffects.gunshot = buffer;
            console.log("Gunshot audio loaded successfully");
          })
          .catch((e) => console.log("Failed to load gunshot audio:", e));

        clock = new THREE.Clock();
        createRealisticWorld();
        createGun();

        setupInput();
        animate();
      }

      function enableShadows(mesh) {
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        if (mesh.children) {
          mesh.children.forEach((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        }
      }

      function createRealisticWorld() {
        // Textured Ground
        const groundGeom = new THREE.PlaneGeometry(
          ARENA_SIZE * 2.5,
          ARENA_SIZE * 2.5
        );
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x1b5e20 }); // Dark Grass
        const ground = new THREE.Mesh(groundGeom, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Realistic Road
        const roadGeom = new THREE.PlaneGeometry(ARENA_SIZE * 2.5, 20);
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x212121 });
        const road = new THREE.Mesh(roadGeom, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0.02;
        scene.add(road);

        // Buildings with "Windows" - inside arena only
        for (let i = 0; i < 15; i++) {
          const w = 8,
            d = 8,
            h = 15 + Math.random() * 25;
          const building = new THREE.Group();
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            new THREE.MeshStandardMaterial({ color: 0x757575 })
          );

          // Window detailing
          const winGeom = new THREE.PlaneGeometry(0.6, 0.8);
          const winMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
          for (let y = 2; y < h - 2; y += 3) {
            for (let x = -2; x <= 2; x += 1.5) {
              const win = new THREE.Mesh(winGeom, winMat);
              win.position.set(x, y - h / 2, d / 2 + 0.01);
              building.add(win);
            }
          }

          building.add(body);
          let buildingX, buildingZ;
          do {
            buildingX = Math.random() * (ARENA_SIZE * 1.5) - ARENA_SIZE * 0.75;
            buildingZ = Math.random() * (ARENA_SIZE * 1.5) - ARENA_SIZE * 0.75;
          } while (
            Math.sqrt(buildingX * buildingX + buildingZ * buildingZ) >
            ARENA_SIZE - 15
          );
          building.position.set(buildingX, h / 2, buildingZ);
          enableShadows(building);
          scene.add(building);
          buildings.push({
            position: new THREE.Vector3(buildingX, h / 2, buildingZ),
            size: Math.max(w, d) / 2 + 2,
          });
        }

        // Trees
        for (let i = 0; i < 60; i++) {
          const tree = new THREE.Group();
          const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.4, 3),
            new THREE.MeshStandardMaterial({ color: 0x3e2723 })
          );
          const leaves = new THREE.Mesh(
            new THREE.SphereGeometry(2, 8, 8),
            new THREE.MeshStandardMaterial({ color: 0x2e7d32 })
          );
          leaves.position.y = 2.5;
          tree.add(trunk, leaves);
          tree.position.set(
            Math.random() * 220 - 110,
            1.5,
            Math.random() * 220 - 110
          );
          if (Math.abs(tree.position.z) > 15) scene.add(tree);
        }

        for (let i = 0; i < 25; i++) spawnNPC();
      }

      function createGun() {
        const gunGroup = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(0.12, 0.25, 0.8),
          new THREE.MeshStandardMaterial({ color: 0x111111 })
        );
        const barrel = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 0.4),
          new THREE.MeshStandardMaterial({ color: 0x000000 })
        );
        barrel.rotation.x = Math.PI / 2;
        barrel.position.z = -0.5;
        gunGroup.add(body, barrel);

        muzzleFlash = new THREE.PointLight(0xffaa00, 0, 10);
        muzzleFlash.position.set(0, 0, -0.8);
        gunGroup.add(muzzleFlash);

        gunGroup.position.set(0.35, -0.3, -0.6);
        camera.add(gunGroup);
      }

      function spawnNPC(isBoss = false, isBomber = false) {
        const scale = isBoss ? 5 : 1;
        const group = new THREE.Group();

        // Skin and clothes
        const skinMat = new THREE.MeshStandardMaterial({
          color: isBoss ? 0x1b5e20 : 0xffdbac,
        });
        const clothMat = new THREE.MeshStandardMaterial({
          color: isBomber ? 0x8b0000 : isBoss ? 0x212121 : 0x1565c0,
        });

        const torso = new THREE.Mesh(
          new THREE.BoxGeometry(0.6 * scale, 1 * scale, 0.4 * scale),
          clothMat
        );
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.5 * scale, 0.5 * scale, 0.5 * scale),
          skinMat
        );
        head.position.y = 0.8 * scale;

        // Face detailing (Eyes)
        const eyeGeom = new THREE.BoxGeometry(
          0.1 * scale,
          0.1 * scale,
          0.1 * scale
        );
        const eyeMat = new THREE.MeshBasicMaterial({
          color: isBoss ? 0xff0000 : 0x000000,
        });
        const eyeL = new THREE.Mesh(eyeGeom, eyeMat);
        eyeL.position.set(-0.15 * scale, 0.9 * scale, 0.26 * scale);
        const eyeR = new THREE.Mesh(eyeGeom, eyeMat);
        eyeR.position.set(0.15 * scale, 0.9 * scale, 0.26 * scale);

        group.add(torso, head, eyeL, eyeR);

        // Arms - for realistic look
        const armGeom = new THREE.BoxGeometry(
          0.15 * scale,
          0.9 * scale,
          0.15 * scale
        );
        const armMat = new THREE.MeshStandardMaterial({
          color: 0xffdbac,
        });
        const lArm = new THREE.Mesh(armGeom, armMat);
        lArm.position.set(-0.4 * scale, 0.2 * scale, 0);
        const rArm = new THREE.Mesh(armGeom, armMat);
        rArm.position.set(0.4 * scale, 0.2 * scale, 0);
        group.add(lArm, rArm);

        // Legs
        const limbGeom = new THREE.BoxGeometry(
          0.2 * scale,
          0.8 * scale,
          0.2 * scale
        );
        const lLeg = new THREE.Mesh(limbGeom, clothMat);
        lLeg.position.set(-0.2 * scale, -0.9 * scale, 0);
        const rLeg = new THREE.Mesh(limbGeom, clothMat);
        rLeg.position.set(0.2 * scale, -0.9 * scale, 0);
        group.add(lLeg, rLeg);

        // Bomb on body if bomber
        if (isBomber) {
          const bombGeom = new THREE.SphereGeometry(0.2 * scale, 8, 8);
          const bombMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
          const bomb = new THREE.Mesh(bombGeom, bombMat);
          bomb.position.y = 0.3 * scale;
          group.add(bomb);
        }

        const yOffset = 1.3 * scale;
        let spawnX, spawnZ;
        const spawnRadius = 0.6 * scale + 3; // NPC body radius + buffer
        let hasCollision;
        do {
          spawnX = Math.random() * ARENA_SIZE * 1.8 - ARENA_SIZE * 0.9;
          spawnZ = Math.random() * ARENA_SIZE * 1.8 - ARENA_SIZE * 0.9;
          // Check if spawn position collides with any building
          hasCollision = false;
          const spawnPos = new THREE.Vector3(spawnX, yOffset, spawnZ);
          for (let building of buildings) {
            const distance = spawnPos.distanceTo(building.position);
            if (distance < building.size + spawnRadius) {
              hasCollision = true;
              break;
            }
          }
        } while (hasCollision);
        group.position.set(spawnX, yOffset, spawnZ);

        // Create physics body for NPC
        const npcRadius = 0.3 * scale;
        const npcShape = new CANNON.Sphere(npcRadius);
        const npcBody = new CANNON.Body({
          mass: isBoss ? 5 : 1,
          shape: npcShape,
          linearDamping: 0.5,
          angularDamping: 0.8,
        });
        npcBody.position.set(spawnX, yOffset, spawnZ);
        physicsWorld.addBody(npcBody);

        // Increase speed and damage every second (more aggressive difficulty)
        const elapsedTime = clock.getElapsedTime();
        const speedMultiplier = 1 + elapsedTime / 60; // Speed increases every 60 seconds
        const damageMultiplier = 1 + elapsedTime / 90; // Damage increases every 90 seconds

        const npc = {
          mesh: group,
          body: npcBody,
          health: isBoss ? 500 : 100,
          speed: (isBoss ? 0.05 : 0.08) * speedMultiplier,
          baseSpeed: (isBoss ? 0.4 : 0.6) * speedMultiplier,
          damageMultiplier: damageMultiplier,
          isBoss: isBoss,
          isBomber: isBomber,
          yBase: yOffset,
          lastBombTime: 0,
          hasAttacked: false,
          // Random movement properties
          randomDirection: new THREE.Vector3(
            Math.random() - 0.5,
            0,
            Math.random() - 0.5
          ).normalize(),
          randomDirectionChangeTime: Math.random() * 3 + 2, // Change direction every 2-5 seconds
          randomDirectionTimer: 0,
        };
        npcs.push(npc);
        scene.add(group);
        if (isBoss)
          document.getElementById("boss-warning").style.display = "block";
      }

      function createBloodSplatter(position) {
        const splatterGroup = new THREE.Group();
        const particleCount = 30; // Increased from 15

        for (let i = 0; i < particleCount; i++) {
          const size = 0.08 + Math.random() * 0.2;
          const geometry = new THREE.SphereGeometry(size, 6, 6);

          // Better blood color variation (darker reds and browns)
          const bloodColor = new THREE.Color().setHSL(
            0 + Math.random() * 0.05,
            0.7 + Math.random() * 0.3,
            0.25 + Math.random() * 0.15
          );

          const material = new THREE.MeshBasicMaterial({
            color: bloodColor,
            transparent: true,
            opacity: 0.85,
          });
          const particle = new THREE.Mesh(geometry, material);
          particle.position.copy(position);

          // Better trajectory with more spread
          const angle = Math.random() * Math.PI * 2;
          const elevation = Math.random() * Math.PI * 0.3;
          const speed = 1.5 + Math.random() * 2;

          particle.velocity = new THREE.Vector3(
            Math.sin(elevation) * Math.cos(angle) * speed,
            (Math.random() + 1) * speed * 0.5,
            Math.sin(elevation) * Math.sin(angle) * speed
          );
          splatterGroup.add(particle);
        }

        scene.add(splatterGroup);
        bloodSplatters.push({
          mesh: splatterGroup,
          time: 0,
          lifetime: 2.0, // Longer lifetime
        });
      }

      function showPopupNotification(message, color = "#ff0000") {
        const notification = document.createElement("div");
        notification.style.position = "fixed";
        notification.style.top = "50%";
        notification.style.left = "50%";
        notification.style.transform = "translate(-50%, -50%)";
        notification.style.backgroundColor = `rgba(${hexToRgb(color)}, 0.9)`;
        notification.style.color = "#ffff00";
        notification.style.padding = "30px 60px";
        notification.style.fontSize = "36px";
        notification.style.fontWeight = "bold";
        notification.style.borderRadius = "15px";
        notification.style.zIndex = "1000";
        notification.style.border = `4px solid ${color}`;
        notification.style.textShadow = "3px 3px 6px #000";
        notification.style.animation = "pulse 0.6s ease-in-out";
        notification.style.fontFamily = '"Segoe UI", sans-serif';
        notification.innerText = message;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.remove();
        }, 2500);
      }

      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
          ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(
              result[3],
              16
            )}`
          : "255, 0, 0";
      }

      function spawnBats() {
        if (!isApocalypse) return;
        // Spawn 4 bats
        for (let i = 0; i < 4; i++) {
          // Create bat as a simple triangle wing shape
          const batGroup = new THREE.Group();

          // Bat body
          const bodyGeom = new THREE.SphereGeometry(0.3, 8, 8);
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            emissive: 0x330000,
          });
          const body = new THREE.Mesh(bodyGeom, bodyMat);
          batGroup.add(body);

          // Bat wings (simple planes)
          const wingGeom = new THREE.ConeGeometry(0.8, 0.4, 8);
          const wingMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            emissive: 0x220000,
          });
          const leftWing = new THREE.Mesh(wingGeom, wingMat);
          leftWing.position.set(-0.5, 0, 0);
          leftWing.rotation.z = Math.PI / 4;
          batGroup.add(leftWing);

          const rightWing = new THREE.Mesh(wingGeom, wingMat);
          rightWing.position.set(0.5, 0, 0);
          rightWing.rotation.z = -Math.PI / 4;
          batGroup.add(rightWing);

          // Spawn at NPC height (low to ground)
          const spawnX = (Math.random() - 0.5) * 80;
          const spawnZ = (Math.random() - 0.5) * 80;
          const spawnY = 3; // Just above player head height

          batGroup.position.set(spawnX, spawnY, spawnZ);
          scene.add(batGroup);

          bats.push({
            mesh: batGroup,
            health: 15,
            speed: 0.12,
            lastAttackTime: 0,
            hasAttacked: false,
          });
        }
        // Show bat spawn notification
        showPopupNotification("‚ö†Ô∏è BATS SPAWNING ‚ö†Ô∏è", "#ff6600");
        playSimpleTone(250, 0.2, 0.3);
      }

      function createDragonFireEffect(position) {
        // Create fire particles for dragon attack
        const fireGroup = new THREE.Group();
        const fireCount = 20; // Increased from 12

        for (let i = 0; i < fireCount; i++) {
          const size = 0.4 + Math.random() * 0.7;
          const geometry = new THREE.SphereGeometry(size, 8, 8);
          const fireColor = new THREE.Color().setHSL(
            0.03 + Math.random() * 0.12, // Red to orange hue
            1,
            0.4 + Math.random() * 0.4
          );
          const material = new THREE.MeshBasicMaterial({
            color: fireColor,
            transparent: true,
            opacity: 0.9,
          });
          const particle = new THREE.Mesh(geometry, material);
          particle.position.copy(position);

          const angle = Math.random() * Math.PI * 2;
          const elevation = Math.random() * Math.PI * 0.5;
          const speed = 3 + Math.random() * 4;
          particle.velocity = new THREE.Vector3(
            Math.sin(elevation) * Math.cos(angle) * speed,
            (Math.random() + 0.8) * speed * 0.9,
            Math.sin(elevation) * Math.sin(angle) * speed
          );
          particle.life = 2; // Lifetime in seconds
          particle.originalOpacity = 0.9;
          fireGroup.add(particle);
        }

        // Add glow light effect
        const fireLight = new THREE.PointLight(0xff6600, 2, 30);
        fireLight.position.copy(position);
        fireGroup.add(fireLight);
        fireGroup.fireLight = fireLight;

        scene.add(fireGroup);
        bloodSplatters.push({
          mesh: fireGroup,
          time: 0,
          lifetime: 2,
          isFire: true,
        });

        // Play fire sound
        playSimpleTone(150, 0.4, 0.5);
      }

      function throwBomb(npc) {
        if (!isApocalypse || !npc.isBomber) return;
        const now = clock.getElapsedTime();
        if (now - npc.lastBombTime < 2) return; // Cooldown between bombs

        npc.lastBombTime = now;
        const bombGeom = new THREE.SphereGeometry(0.4, 16, 16);
        const bombMat = new THREE.MeshStandardMaterial({
          color: 0x333333,
          metalness: 0.3,
          roughness: 0.7,
          emissive: 0x1a1a1a,
        });
        const bomb = new THREE.Mesh(bombGeom, bombMat);
        bomb.castShadow = true;
        bomb.receiveShadow = true;

        // Start from zombie hand position
        bomb.position.copy(npc.mesh.position);
        bomb.position.y += 1.2; // Throw from hand height
        scene.add(bomb);

        // Play bomb throw sound
        playSimpleTone(150, 0.15, 0.25);

        // Direction towards player with upward arc
        const directionToPlayer = camera.position
          .clone()
          .sub(npc.mesh.position);
        const distance = directionToPlayer.length();

        // Normalize only X and Z for horizontal direction
        const horizontalDirection = new THREE.Vector3(
          directionToPlayer.x,
          0,
          directionToPlayer.z
        ).normalize();

        // Increase speed based on distance to player
        const bombSpeed = 0.5 + distance * 0.1;
        const upwardForce = 0.8;

        bombs.push({
          mesh: bomb,
          velocity: new THREE.Vector3(
            horizontalDirection.x * bombSpeed,
            upwardForce,
            horizontalDirection.z * bombSpeed
          ),
          time: 0,
          hasDetonated: false,
        });
      }

      function createExplosion(position) {
        const explosionGroup = new THREE.Group();
        const particleCount = 50; // Increased from 25

        for (let i = 0; i < particleCount; i++) {
          const size = 0.1 + Math.random() * 0.3;
          const geometry = new THREE.SphereGeometry(size, 8, 8);

          // Better explosion colors: hot reds, yellows, and oranges
          const hue = Math.random() * 0.15; // Red to orange range
          const saturation = 0.9 + Math.random() * 0.1;
          const lightness = 0.4 + Math.random() * 0.2;

          const material = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(hue, saturation, lightness),
            transparent: true,
            opacity: 0.9,
          });
          const particle = new THREE.Mesh(geometry, material);
          particle.position.copy(position);

          // Radial explosion pattern with varied speeds
          const angle = Math.random() * Math.PI * 2;
          const elevation = Math.random() * Math.PI * 0.4;
          const speed = 2 + Math.random() * 3;

          particle.velocity = new THREE.Vector3(
            Math.sin(elevation) * Math.cos(angle) * speed,
            1.0 + Math.random() * 2,
            Math.sin(elevation) * Math.sin(angle) * speed
          );
          explosionGroup.add(particle);
        }

        scene.add(explosionGroup);
        bloodSplatters.push({
          mesh: explosionGroup,
          time: 0,
          lifetime: 1.5,
        });
      }

      function shoot() {
        if (!controls.isLocked || player.isDead) return;
        muzzleFlash.intensity = 20;
        playSimpleTone(150, 0.1, 0.3);
        setTimeout(() => (muzzleFlash.intensity = 0), 50);

        const ray = new THREE.Raycaster();
        ray.setFromCamera(new THREE.Vector2(0, 0), camera);

        // Check NPCs
        const npcHits = ray.intersectObjects(
          npcs.map((n) => n.mesh),
          true
        );

        if (npcHits.length > 0) {
          let hitObj = npcHits[0].object;
          while (hitObj.parent && !npcs.find((n) => n.mesh === hitObj))
            hitObj = hitObj.parent;
          const npc = npcs.find((n) => n.mesh === hitObj);

          if (npc) {
            if (!isApocalypse) {
              isApocalypse = true;

              // HORROR THEME: Darken sky dramatically
              scene.background = new THREE.Color(0x0f0f1e);
              scene.fog = new THREE.FogExp2(0x0f0f1e, 0.025);

              // Make the world darker and more menacing
              const ambientLight = scene.children.find(
                (c) => c instanceof THREE.AmbientLight
              );
              if (ambientLight) ambientLight.intensity = 0.2;

              // Add red/orange emergency lighting for horror effect
              const horrorLight = new THREE.DirectionalLight(0xff4400, 0.4);
              horrorLight.position.set(-50, 80, -50);
              scene.add(horrorLight);

              // Add sinister point lights for creepy atmosphere
              const redLight1 = new THREE.PointLight(0xff2200, 0.5, 150);
              redLight1.position.set(-80, 40, 0);
              scene.add(redLight1);

              const redLight2 = new THREE.PointLight(0xff2200, 0.5, 150);
              redLight2.position.set(80, 40, 0);
              scene.add(redLight2);

              // Make zombies glow green
              npcs.forEach((n) =>
                n.mesh.children.forEach((c) => {
                  if (c.material) c.material.color.set(0x4caf50);
                })
              );
            }
            npc.health -= 50;
            // Create blood splatter at hit location
            createBloodSplatter(npcHits[0].point);
            // Play gunshot sound effect
            if (soundEffects.gunshot) {
              playAudioBuffer(soundEffects.gunshot, 0.7);
            } else {
              playSimpleTone(300, 0.05, 0.2); // Fallback if gunshot not loaded
            }
            if (npc.health <= 0) {
              scene.remove(npc.mesh);
              npcs = npcs.filter((n) => n !== npc);
              const wasFirstKill = player.kills === 0;
              player.kills += npc.isBoss ? 10 : 1;
              player.health = Math.min(100, player.health + 5);

              // Play audio and scream on first kill
              if (wasFirstKill) {
                if (!firstKillPlayed) {
                  firstKillPlayed = true;
                  // Play loaded background audio on loop
                  if (soundEffects.background) {
                    playLoopingAudio(soundEffects.background, 0.4);
                  }
                }
                setTimeout(() => playSimpleTone(400, 0.5, 0.4), 100);
              }

              if (npc.isBoss)
                document.getElementById("boss-warning").style.display = "none";
              spawnNPC();
            }
            return;
          }
        }

        // Check bats
        const batHits = ray.intersectObjects(
          bats.map((b) => b.mesh),
          true
        );

        if (batHits.length > 0) {
          const hitBat = bats.find(
            (b) =>
              batHits[0].object.parent === b.mesh ||
              batHits[0].object === b.mesh
          );
          if (hitBat) {
            hitBat.health -= 20;
            playSimpleTone(600, 0.1, 0.2);
            player.kills += 0.5;
            if (hitBat.health <= 0) {
              scene.remove(hitBat.mesh);
              bats = bats.filter((b) => b !== hitBat);
              createBloodSplatter(batHits[0].point);
            }
            return;
          }
        }
      }

      function animate() {
        if (player.isDead) return;
        requestAnimationFrame(animate);

        // Skip animation updates if paused, but still render
        if (isPaused) {
          renderer.render(scene, camera);
          return;
        }

        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // Update physics world
        if (physicsWorld) {
          physicsWorld.step(1 / 60, delta, 3);
        }

        // Giant zombie spawning with incremental delays: 30s, 40s, 50s, 60s...
        let shouldSpawnGiant = false;
        if (isApocalypse) {
          if (time >= 30 && lastGiantSpawnTime === 0) {
            shouldSpawnGiant = true;
          } else if (lastGiantSpawnTime > 0) {
            // Calculate next spawn delay: 40s, 50s, 60s... (10s increment)
            const nextSpawnDelay = 30 + (giantZombieCount + 1) * 10;
            if (time - lastGiantSpawnTime > nextSpawnDelay) {
              shouldSpawnGiant = true;
            }
          }
        }

        if (shouldSpawnGiant) {
          // Double the number of giants each spawn: 1, 2, 4, 8...
          const giantsToSpawn = Math.pow(2, giantZombieCount);
          const bombersToSpawn = giantsToSpawn * 2;

          // Spawn the calculated number of giants and bombers
          for (let i = 0; i < giantsToSpawn; i++) {
            spawnNPC(true, false);
          }
          for (let i = 0; i < bombersToSpawn; i++) {
            spawnNPC(false, true);
          }
          giantZombieCount++; // Increment counter for next spawn
          lastGiantSpawnTime = time;
        }

        if (controls.isLocked) {
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;
          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize();

          if (moveForward || moveBackward)
            velocity.z += direction.z * 100.0 * delta;
          if (moveLeft || moveRight) velocity.x += direction.x * 100.0 * delta;

          // Check collision BEFORE movement
          const p = controls.getObject().position;
          const nextX = p.x + velocity.x * delta;
          const nextZ = p.z + velocity.z * delta;
          const checkPos = new THREE.Vector3(nextX, 1.3, nextZ);

          // Only move if no building collision
          const hasCollision = checkBuildingCollision(checkPos);
          if (!hasCollision) {
            controls.moveRight(velocity.x * delta);
            controls.moveForward(velocity.z * delta);
          } else {
            // Stop velocity on collision
            velocity.x = 0;
            velocity.z = 0;
          }

          // Arena Clamp
          p.x = Math.max(-ARENA_SIZE, Math.min(ARENA_SIZE, p.x));
          p.z = Math.max(-ARENA_SIZE, Math.min(ARENA_SIZE, p.z));
          p.y = PLAYER_HEIGHT; // Enforce player height
        }

        // Update bombs
        bombs = bombs.filter((bomb) => {
          bomb.time += delta;
          bomb.velocity.y -= 9.8 * delta; // Gravity
          bomb.mesh.position.add(bomb.velocity.clone().multiplyScalar(delta));

          // Check collision with player (larger radius)
          const distToPlayer = bomb.mesh.position.distanceTo(camera.position);
          if (distToPlayer < 1.5 && !bomb.hasDetonated) {
            bomb.hasDetonated = true;
            createExplosion(bomb.mesh.position);
            createDebrisExplosion(bomb.mesh.position);
            playSimpleTone(100, 0.3, 0.4);
            scene.remove(bomb.mesh);
            const baseBombDamage = 40;
            const bombDamageMultiplier = 1 + clock.getElapsedTime() / 200;
            player.health -= baseBombDamage * bombDamageMultiplier;
            createBloodSplatter(camera.position, true); // Show blood from impact
            return false;
          }

          // Check if below ground
          if (bomb.mesh.position.y < -5) {
            if (!bomb.hasDetonated) {
              bomb.hasDetonated = true;
              createExplosion(bomb.mesh.position);
              createDebrisExplosion(bomb.mesh.position);
            }
            scene.remove(bomb.mesh);
            return false;
          }

          return true;
        });

        // Update blood splatters and explosions
        bloodSplatters = bloodSplatters.filter((splat) => {
          splat.time += delta;
          let aliveParticles = 0;

          splat.mesh.children.forEach((particle) => {
            if (!splat.isEnvironmental) {
              particle.velocity.y -= 9.8 * delta; // Gravity
            } else {
              // Slow drift for environmental particles
              particle.velocity.y -= 0.5 * delta;
            }

            particle.position.add(
              particle.velocity.clone().multiplyScalar(delta)
            );

            // Rotate debris
            if (splat.isDebris && particle.angularVelocity) {
              particle.rotation.x += particle.angularVelocity.x * delta;
              particle.rotation.y += particle.angularVelocity.y * delta;
              particle.rotation.z += particle.angularVelocity.z * delta;
            }

            const progress = splat.time / splat.lifetime;
            if (progress < 1) {
              particle.material.opacity = Math.max(
                0,
                particle.material.opacity * (1 - progress * 0.5)
              );
              aliveParticles++;
            }
          });

          if (splat.isEnvironmental) {
            // Environmental particles never die
            return true;
          }

          if (aliveParticles === 0) {
            scene.remove(splat.mesh);
            return false;
          }
          return true;
        });

        npcs.forEach((npc) => {
          // Sync physics body with mesh
          npc.mesh.position.copy(npc.body.position);
          npc.mesh.quaternion.copy(npc.body.quaternion);

          // Update zombie speed based on elapsed time (increase every 60 seconds)
          const minutesElapsed = Math.floor(time / 60);
          npc.speed = npc.baseSpeed * (1 + minutesElapsed * 0.15); // 15% increase per minute

          // Subtle walking bob
          npc.mesh.position.y =
            npc.yBase + Math.sin(time * 10) * (npc.isBoss ? 0.1 : 0.05);

          if (!isApocalypse) {
            // BEFORE APOCALYPSE: NPCs move randomly and don't attack
            npc.randomDirectionTimer += delta;

            // Change random direction periodically
            if (npc.randomDirectionTimer > npc.randomDirectionChangeTime) {
              npc.randomDirection = new THREE.Vector3(
                Math.random() - 0.5,
                0,
                Math.random() - 0.5
              ).normalize();
              npc.randomDirectionChangeTime = Math.random() * 3 + 2;
              npc.randomDirectionTimer = 0;
            }

            // Move in random direction
            const randomForce = npc.speed * (npc.body.mass || 1);
            npc.body.velocity.x = npc.randomDirection.x * randomForce;
            npc.body.velocity.z = npc.randomDirection.z * randomForce;
            npc.body.velocity.y = Math.max(npc.body.velocity.y, -5);

            // Rotate to face movement direction
            npc.mesh.lookAt(
              npc.mesh.position.x + npc.randomDirection.x,
              npc.mesh.position.y,
              npc.mesh.position.z + npc.randomDirection.z
            );
          } else {
            // AFTER APOCALYPSE: NPCs chase and attack the player AGGRESSIVELY
            const distanceToPlayer = npc.mesh.position.distanceTo(
              camera.position
            );

            npc.mesh.lookAt(
              camera.position.x,
              npc.mesh.position.y,
              camera.position.z
            );

            // Apply STRONGER force to move towards player using physics
            const direction = camera.position
              .clone()
              .sub(npc.mesh.position)
              .normalize();

            // Much higher force for aggressive charging
            const baseMass = npc.body.mass || 1;
            const force = npc.speed * baseMass * 3; // 3x multiplier for aggressive charge

            npc.body.velocity.x = direction.x * force;
            npc.body.velocity.z = direction.z * force;
            npc.body.velocity.y = Math.max(npc.body.velocity.y, -5); // Prevent falling too fast

            // Bomber throws bombs during apocalypse - increased range
            if (npc.isBomber) {
              throwBomb(npc);
            }

            // Attack during apocalypse - larger range to hit faster
            const attackRange = npc.isBoss ? 10 : 3; // Increased range

            if (distanceToPlayer < attackRange) {
              // Start attacking
              if (!npc.hasAttacked) {
                npc.hasAttacked = true;
                const attackingZombies = npcs.filter(
                  (n) => n.hasAttacked
                ).length;
                if (attackingZombies > 0 && !backgroundAudio) {
                  backgroundAudio = playSimpleTone(80, 0.5, 0.2, "sine");
                }
                playSimpleTone(200, 0.2, 0.3);
              }
              // Continuous damage while attacking - scales with NPC difficulty
              const baseDamage = 0.3;
              player.health -= baseDamage * npc.damageMultiplier;
            } else {
              // Reset attack when far enough
              if (npc.hasAttacked && distanceToPlayer > attackRange + 3) {
                npc.hasAttacked = false;
              }
            }
          }
        });

        // Spawn bats every 45 seconds
        if (isApocalypse && time - lastBatSpawnTime > 45) {
          spawnBats();
          lastBatSpawnTime = time;
        }

        // Update bats
        bats = bats.filter((bat) => {
          if (bat.health <= 0) {
            scene.remove(bat.mesh);
            return false;
          }

          // Move toward player flying in sky
          const directionToPlayer = camera.position
            .clone()
            .sub(bat.mesh.position)
            .normalize();
          bat.mesh.position.add(directionToPlayer.multiplyScalar(bat.speed));

          // Keep bat close to ground (slightly above player)
          if (bat.mesh.position.y < 2.5) {
            bat.mesh.position.y = 2.5;
          }
          if (bat.mesh.position.y > 8) {
            bat.mesh.position.y = 8;
          }

          // Attack player when close
          const distToBat = bat.mesh.position.distanceTo(camera.position);
          if (distToBat < 5) {
            const now = clock.getElapsedTime();
            if (now - bat.lastAttackTime > 0.5) {
              bat.lastAttackTime = now;
              const batDamageMultiplier = 1 + clock.getElapsedTime() / 120;
              player.health -= 5 * batDamageMultiplier;
              playSimpleTone(400, 0.1, 0.2);
            }
          }

          return true;
        });

        // UI
        document.getElementById("health-bar").style.width = player.health + "%";
        document.getElementById("kills").innerText = player.kills;
        document.getElementById("timer").innerText = Math.floor(time);
        const wave = Math.floor(time / 30) + 1;
        document.getElementById("wave").innerText = wave;

        // Send multiplayer updates every 100ms
        if (isMultiplayer && Math.floor(time * 10) % 1 === 0) {
          sendPlayerUpdate();
        }

        if (player.health <= 0) {
          player.isDead = true;
          controls.unlock();
          document.getElementById("ui").style.display = "none";

          // Update stats display
          document.getElementById("stat-kills").innerText = player.kills;
          document.getElementById("stat-time").innerText = Math.floor(time);
          document.getElementById("stat-wave").innerText = wave;

          // Save game stats to Convex database
          saveGameStats(player.name, player.kills, Math.floor(time), wave);

          if (backgroundAudio) {
            try {
              backgroundAudio.stop();
            } catch (e) {}
            backgroundAudio = null;
          }

          // Show game-over screen after 1.5 second delay to allow data save
          setTimeout(() => {
            document.getElementById("game-over").style.display = "flex";
          }, 1500);
        }

        renderer.render(scene, camera);
      }

      // Touch Controls for Mobile
      let touchStartX = 0;
      let touchStartY = 0;
      let isTouchMoving = false;
      const TOUCH_MOVE_THRESHOLD = 10;

      function setupTouchControls() {
        document.addEventListener("touchstart", (e) => {
          if (!controls.isLocked) return;

          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        });

        document.addEventListener("touchmove", (e) => {
          if (!controls.isLocked) return;
          e.preventDefault();

          const touch = e.touches[0];
          const deltaX = touch.clientX - touchStartX;
          const deltaY = touch.clientY - touchStartY;

          // Camera look with touch
          if (
            Math.abs(deltaX) > TOUCH_MOVE_THRESHOLD ||
            Math.abs(deltaY) > TOUCH_MOVE_THRESHOLD
          ) {
            isTouchMoving = true;

            // Simple camera movement
            const rotationSpeed = 0.003;
            const euler = new THREE.Euler(0, 0, 0, "YXZ");
            euler.setFromQuaternion(camera.quaternion);
            euler.rotateY(-deltaX * rotationSpeed);
            euler.rotateX(-deltaY * rotationSpeed);
            camera.quaternion.setFromEuler(euler);

            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
          }
        });

        document.addEventListener("touchend", (e) => {
          isTouchMoving = false;
          if (e.touches.length === 0) {
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
          }
        });

        // Virtual joystick for movement (optional visual enhancement)
        document.addEventListener("touch", (e) => {
          if (e.touches.length === 2) {
            // Two-finger touch for shooting
            shoot();
          }
        });
      }

      function pauseGame() {
        if (player.isDead) return;
        isPaused = true;
        pausedTime = clock.getElapsedTime();
        controls.unlock();
        document.getElementById("pause-menu").classList.add("active");
        document.getElementById("ui").style.display = "none";
      }

      function resumeGame() {
        isPaused = false;
        document.getElementById("pause-menu").classList.remove("active");
        document.getElementById("ui").style.display = "block";
        controls.lock();
      }

      function returnToMenu() {
        location.reload();
      }

      function setupInput() {
        // Keyboard controls
        document.addEventListener("keydown", (e) => {
          if (e.code === "KeyW") moveForward = true;
          if (e.code === "KeyS") moveBackward = true;
          if (e.code === "KeyA") moveLeft = true;
          if (e.code === "KeyD") moveRight = true;
          // Pause with ESC key
          if (e.code === "Escape") {
            if (controls.isLocked) {
              pauseGame();
            }
          }
        });
        document.addEventListener("keyup", (e) => {
          if (e.code === "KeyW") moveForward = false;
          if (e.code === "KeyS") moveBackward = false;
          if (e.code === "KeyA") moveLeft = false;
          if (e.code === "KeyD") moveRight = false;
        });
        document.addEventListener("mousedown", shoot);
        // Play background audio on first user interaction (browser autoplay policy)
        document.addEventListener(
          "click",
          () => {
            if (soundEffects.background && !soundEffects.backgroundPlaying) {
              playLoopingAudio(soundEffects.background, 0.4);
              soundEffects.backgroundPlaying = true;
            }
          },
          { once: true }
        );
        document.addEventListener("mousemove", (e) => {
          // Ensure PointerLockControls receives mouse movement
          if (controls && controls.isLocked) {
            controls.onMouseMove(e);
          }
        });

        // Setup touch controls for mobile
        if ("ontouchstart" in window) {
          setupTouchControls();
        }
      }

      window.startGame = function () {
        const name = document.getElementById("username").value;
        if (!name) return alert("ENTER YOUR NAME");
        player.name = name;
        document.getElementById("menu").style.display = "none";
        document.getElementById("ui").style.display = "block";
        document.getElementById("pName").innerText = name;

        // Try to connect to multiplayer (optional)
        // initMultiplayer("ws://your-server.com:8080");

        init();
        player.startTime = 0;
        controls.lock();
      };

      // Assign to global function
      startGameFunc = window.startGame;
    </script>
  </body>
</html>
